# 函数的暂时性死区

参数是按顺序被赋值的，因此，前面的参数不可以引用后面的参数的默认值，也不能引用函数体中的成员值，这就是“暂时性死区”规则，例如：

```js
function  example(a=b,  b=1,c=data){
    const data=1
}
```

这段代码有两处错误：
* 参数a不能引用后面的参数b的值
* 参数c不能引用后面的函数体成员data的值

而下面这个例子是正确的：

```js
function  example(a=1 , b=a){
    const data=b
    console.log(data)
}
example()      //=>1
```

其实，简单来讲，所谓**暂时性死区**，不过也遵循了局部作用域的声明规则。使用let和const声明的时候，声明和引用是按顺序来的，即只能先声明后引用，后面的引用前面的，反过来不可以，不存在声明提升。
