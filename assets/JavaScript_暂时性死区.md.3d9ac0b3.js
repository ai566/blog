import{_ as s,o as a,c as n,Q as p}from"./chunks/framework.9bc09dc8.js";const _=JSON.parse('{"title":"函数的暂时性死区","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/暂时性死区.md","filePath":"JavaScript/暂时性死区.md"}'),l={name:"JavaScript/暂时性死区.md"},o=p(`<h1 id="函数的暂时性死区" tabindex="-1">函数的暂时性死区 <a class="header-anchor" href="#函数的暂时性死区" aria-label="Permalink to &quot;函数的暂时性死区&quot;">​</a></h1><p>参数是按顺序被赋值的，因此，前面的参数不可以引用后面的参数的默认值，也不能引用函数体中的成员值，这就是“暂时性死区”规则，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">example</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">a</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">b,  </span><span style="color:#FFAB70;">b</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span><span style="color:#FFAB70;">c</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">data){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">data</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">example</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">b,  </span><span style="color:#E36209;">b</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span><span style="color:#E36209;">c</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">data){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">data</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这段代码有两处错误：</p><ul><li>参数a不能引用后面的参数b的值</li><li>参数c不能引用后面的函数体成员data的值</li></ul><p>而下面这个例子是正确的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">example</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">a</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> , </span><span style="color:#FFAB70;">b</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">a){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">data</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">b</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(data)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">example</span><span style="color:#E1E4E8;">()      </span><span style="color:#6A737D;">//=&gt;1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">example</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> , </span><span style="color:#E36209;">b</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">a){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">data</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">b</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(data)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">example</span><span style="color:#24292E;">()      </span><span style="color:#6A737D;">//=&gt;1</span></span></code></pre></div><p>其实，简单来讲，所谓<strong>暂时性死区</strong>，不过也遵循了局部作用域的声明规则。使用let和const声明的时候，声明和引用是按顺序来的，即只能先声明后引用，后面的引用前面的，反过来不可以，不存在声明提升。</p>`,8),e=[o];function t(c,r,y,E,i,d){return a(),n("div",null,e)}const h=s(l,[["render",t]]);export{_ as __pageData,h as default};
